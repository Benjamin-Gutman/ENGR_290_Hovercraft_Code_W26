/#define F_CPU 16000000UL

#include <avr/io.h>
#include <util/delay.h>
#include <stdint.h>

// ---------------- UART (9600, 8N1) ----------------
#define BAUD 9600UL
#define UBRR_VALUE (F_CPU/(BAUD*16UL)-1)

static void uart_init(void) {
    UBRR0H = (uint8_t)(UBRR_VALUE >> 8);
    UBRR0L = (uint8_t)(UBRR_VALUE);
    UCSR0A = 0;
    UCSR0B = (1 << TXEN0); // TX enable
    UCSR0C = (1 << UCSZ01) | (1 << UCSZ00); // 8 data bits, 1 stop, no parity
}

static void uart_tx(uint8_t data) {
    while (!(UCSR0A & (1 << UDRE0))) { }
    UDR0 = data;
}

static void uart_print_str(const char *s) {
    while (*s) uart_tx((uint8_t)*s++);
}

static void uart_print_uint16(uint16_t v) {
    char buf[6];
    int i = 0;

    if (v == 0) {
        uart_tx('0');
        return;
    }

    while (v > 0 && i < 5) {
        buf[i++] = (char)('0' + (v % 10));
        v /= 10;
    }
    while (i--) uart_tx((uint8_t)buf[i]);
}

static void uart_newline(void) {
    uart_tx('\r');
    uart_tx('\n');
}

// -------------- Choose connector pins --------------
// USE_P6 = 1  -> P6:  Echo PD2, Trig PB3  (recommended) :contentReference[oaicite:3]{index=3}
// USE_P6 = 0  -> P13: Echo PD3, Trig PB5 :contentReference[oaicite:4]{index=4}
#define USE_P6 1

#if USE_P6
  #define TRIG_DDR   DDRB
  #define TRIG_PORT  PORTB
  #define TRIG_BIT   PB3

  #define ECHO_DDR   DDRD
  #define ECHO_PORT  PORTD
  #define ECHO_PINR  PIND
  #define ECHO_BIT   PD2
#else
  #define TRIG_DDR   DDRB
  #define TRIG_PORT  PORTB
  #define TRIG_BIT   PB5

  #define ECHO_DDR   DDRD
  #define ECHO_PORT  PORTD
  #define ECHO_PINR  PIND
  #define ECHO_BIT   PD3
#endif

// ---------------- Timer1: prescaler 8 ----------------
// 16 MHz / 8 = 2 MHz => 0.5 us per tick
static void timer1_init(void) {
    TCCR1A = 0;
    TCCR1B = 0;
    TCNT1  = 0;
    TCCR1B = (1 << CS11); // prescaler = 8
}

// --------------- HC-SR04 measurement ----------------
// Returns Timer1 ticks while Echo is HIGH. Returns 0 on timeout.
static uint16_t measure_echo_ticks(void) {
    // Trigger: LOW 2us, HIGH 10us, LOW
    TRIG_PORT &= ~(1 << TRIG_BIT);
    _delay_us(2);
    TRIG_PORT |= (1 << TRIG_BIT);
    _delay_us(10);
    TRIG_PORT &= ~(1 << TRIG_BIT);

    // Wait for Echo HIGH (timeout ~60 ms)
    uint32_t timeout = 60000;
    while (!(ECHO_PINR & (1 << ECHO_BIT))) {
        if (--timeout == 0) return 0;
        _delay_us(1);
    }

    // Start timing
    TCNT1 = 0;

    // Wait for Echo LOW (timeout ~60 ms)
    timeout = 60000;
    while (ECHO_PINR & (1 << ECHO_BIT)) {
        if (--timeout == 0) return 0;
        _delay_us(1);
    }

    return TCNT1;
}

int main(void) {
    uart_init();

    // Trig output
    TRIG_DDR  |= (1 << TRIG_BIT);
    TRIG_PORT &= ~(1 << TRIG_BIT);

    // Echo input, no pull-up (sensor drives the line)
    ECHO_DDR  &= ~(1 << ECHO_BIT);
    ECHO_PORT &= ~(1 << ECHO_BIT);

    timer1_init();

    uart_print_str("HC-SR04 ready. Distance in cm:");
    uart_newline();

    while (1) {
        uint16_t ticks = measure_echo_ticks();

        if (ticks == 0) {
            uart_print_str("No echo");
            uart_newline();
        } else {
            // ticks are 0.5 us each. Duration_us = ticks/2.
            // HC-SR04: distance_cm = duration_us / 58
            // => distance_cm = (ticks/2) / 58 = ticks / 116
            uint16_t distance_cm = (uint16_t)(ticks / 116);

            uart_print_uint16(distance_cm);
            uart_print_str(" cm");
            uart_newline();
        }

        _delay_ms(100);
    }
}
