#define F_CPU 16000000UL

#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <stdint.h>
#include <stdlib.h>

/* ---------- User calibration ---------- */
#define D1_CM      14.0f
#define D2_CM      42.0f

/* Your measured ADC reference voltage from RV1 (AREF pin) */
#define AREF_V     4.64f

/* IR on PC3 = ADC3 (P16 pin 1 on ENGR290 board) */
#define IR_ADC_CHANNEL  3

/* ENGR290 board pins:
   LED "L" is PB5 and is ACTIVE LOW.
   D3 brightness is PB3 = OC2A (Timer2 channel A). */
#define LED_L_BIT     PB5
#define PWM_D3_DDR    DDRB
#define PWM_D3_BIT    PB3

/* LED L ACTIVE LOW helpers */
#define LED_L_ON()    (PORTB &= ~(1 << LED_L_BIT))
#define LED_L_OFF()   (PORTB |=  (1 << LED_L_BIT))

/* ---------- 1 ms time base for blinking ---------- */
static volatile uint32_t g_ms = 0;

ISR(TIMER0_COMPA_vect) { g_ms++; }

static void timer0_init_1ms(void) {
    TCCR0A = (1 << WGM01);
    OCR0A  = 249;
    TCCR0B = (1 << CS01) | (1 << CS00);
    TIMSK0 = (1 << OCIE0A);
}

/* ---------- UART 9600 (TX only) ---------- */
#define BAUD     9600UL
#define UBRR_VAL ((F_CPU / (16UL * BAUD)) - 1UL)

static void uart_init(void) {
    UBRR0H = (uint8_t)(UBRR_VAL >> 8);
    UBRR0L = (uint8_t)(UBRR_VAL & 0xFF);
    UCSR0B = (1 << TXEN0);
    UCSR0C = (1 << UCSZ01) | (1 << UCSZ00); /* 8N1 */
}

static void uart_putc(char c) {
    while (!(UCSR0A & (1 << UDRE0))) {}
    UDR0 = c;
}
static void uart_puts(const char *s) { while (*s) uart_putc(*s++); }

static void uart_put_u16(uint16_t x) {
    char buf[6];
    itoa(x, buf, 10);
    uart_puts(buf);
}
static void uart_put_i16(int16_t x) {
    char buf[8];
    itoa(x, buf, 10);
    uart_puts(buf);
}

/* Print float with 2 decimals without printf */
static void uart_put_float_2(float v) {
    int16_t x = (int16_t)(v * 100.0f + (v >= 0 ? 0.5f : -0.5f));
    int16_t ip = x / 100;
    int16_t fp = x % 100;
    if (fp < 0) fp = -fp;

    uart_put_i16(ip);
    uart_putc('.');
    if (fp < 10) uart_putc('0');
    uart_put_u16((uint16_t)fp);
}

/* ---------- ADC (external AREF, no analogRead) ---------- */
static void adc_init_aref(uint8_t channel) {
    /* REFS1:0 = 00 -> External AREF pin (RV1)
       ADLAR = 0 -> right-adjust
       MUX = channel */
    ADMUX = (1 << REFS0) | (channel & 0x07);

    /* Disable digital input buffer on ADC pin (reduces noise) */
    if (channel <= 5) {
        DIDR0 |= (1 << channel); /* channel 3 -> ADC3D bit */
    }

    /* Enable ADC, prescaler 128 -> 16MHz/128 = 125kHz */
    ADCSRA = (1 << ADEN) | (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0);

    /* No auto-trigger */
    ADCSRB = 0;
}

static uint16_t adc_read_blocking(void) {
    ADCSRA |= (1 << ADSC);
    while (ADCSRA & (1 << ADSC)) {}
    return ADC;
}

static uint16_t readIR_Average(uint8_t n) {
    uint32_t sum = 0;
    for (uint8_t i = 0; i < n; i++) {
        sum += adc_read_blocking();
        _delay_ms(2);
    }
    return (uint16_t)(sum / n);
}

/* ---------- PWM on D3 (PB3 = OC2A) ---------- */
static void pwm_d3_init(void) {
    PWM_D3_DDR |= (1 << PWM_D3_BIT);

    /* Fast PWM 8-bit, OC2A inverting (active-low LED hardware) */
    TCCR2A = (1 << WGM21) | (1 << WGM20) | (1 << COM2A1) | (1 << COM2A0);
    TCCR2B = (1 << CS22); /* prescaler 64 */
    OCR2A  = 0;
}
static void pwm_d3_set(uint8_t duty) { OCR2A = duty; }

/* ---------- Calibration table (distance -> ADC) ---------- */
typedef struct {
    uint16_t d_cm;
    uint16_t adc;
} CalPoint;

static const CalPoint cal[] = {
    {  7, 675 },
    {  8, 625 },
    { 10, 533 },
    { 15, 385 },
    { 20, 298 },
    { 25, 251 },
    { 30, 215 },
    { 40, 174 },
    { 50, 138 },
    { 80,  96 }
};

#define CAL_N (sizeof(cal)/sizeof(cal[0]))

/* ADC -> cm piecewise, con EXTRAPOLACION usando la primera y la ultima recta */
static float cm_from_adc_piecewise_extrap(uint16_t adc) {
    uint8_t i;

    /* Extrapola por arriba (mas cerca que 7 cm) con el primer segmento */
    if (adc >= cal[0].adc) {
        i = 0; /* 7-8 cm */
    }
    /* Extrapola por abajo (mas lejos que 80 cm) con el ultimo segmento */
    else if (adc <= cal[CAL_N - 1].adc) {
        i = (uint8_t)(CAL_N - 2); /* 50-80 cm */
    }
    /* Dentro de rango: busca el segmento */
    else {
        for (i = 0; i < (CAL_N - 1); i++) {
            float a0 = (float)cal[i].adc;
            float a1 = (float)cal[i + 1].adc;

            /* Normalmente a0 > a1 (ADC baja cuando cm sube) */
            if (a0 >= a1) {
                if ((float)adc <= a0 && (float)adc >= a1) break;
            } else {
                if ((float)adc >= a0 && (float)adc <= a1) break;
            }
        }
        if (i >= (CAL_N - 1)) i = (uint8_t)(CAL_N - 2);
    }

    float d0 = (float)cal[i].d_cm;
    float d1 = (float)cal[i + 1].d_cm;
    float a0 = (float)cal[i].adc;
    float a1 = (float)cal[i + 1].adc;

    /* Evita division por 0 si dos puntos tuvieran el mismo ADC */
    float den = (a1 - a0);
    if (den == 0.0f) return d0;

    /* t puede ser <0 o >1 cuando extrapola (y esta bien) */
    float t = ((float)adc - a0) / den;
    return d0 + t * (d1 - d0);
}

/* Brightness vs distance requirement:
   d1 or less -> 0%
   d2 or more -> 100%
   linear between */
static uint8_t duty_from_cm(float cm) {
    if (cm <= D1_CM) return 0;
    if (cm >= D2_CM) return 255;

    float t = (cm - D1_CM) / (D2_CM - D1_CM);
    int32_t duty = (int32_t)(t * 255.0f + 0.5f);
    if (duty < 0) duty = 0;
    if (duty > 255) duty = 255;
    return (uint8_t)duty;
}

int main(void) {
    /* LED L output */
    DDRB |= (1 << LED_L_BIT);
    LED_L_OFF();

    /* Ensure PC3 is input and no pull-up */
    DDRC  &= ~(1 << PC3);
    PORTC &= ~(1 << PC3);

    cli();
    timer0_init_1ms();
    adc_init_aref(IR_ADC_CHANNEL);
    pwm_d3_init();
    uart_init();

    /* Dummy conversion */
    (void)adc_read_blocking();

    sei();

    uart_puts("IR mode (ADC3/PC3): ADC, V, cm(extrap), duty\r\n");

    uint32_t last_toggle = 0;
    uint8_t led_state = 0;

    while (1) {
        uint16_t adc = readIR_Average(60);

        float v  = ((float)adc * AREF_V) / 1023.0f;
        float cm = cm_from_adc_piecewise_extrap(adc);

        uint8_t duty = duty_from_cm(cm);
        pwm_d3_set(duty);

        /* Blink LED L when outside [D1_CM, D2_CM] */
        if (cm < D1_CM || cm > D2_CM) {
            if ((g_ms - last_toggle) >= 500) {
                last_toggle = g_ms;
                led_state ^= 1;
                if (led_state) LED_L_ON();
                else           LED_L_OFF();
            }
        } else {
            led_state = 0;
            LED_L_OFF();
        }

        uart_puts("ADC=");
        uart_put_u16(adc);

        uart_puts(" V=");
        uart_put_float_2(v);

        uart_puts(" cm=");
        uart_put_float_2(cm);

        uart_puts(" duty=");
        uart_put_u16(duty);

        uart_puts("\r\n");

        _delay_ms(100);
    }
}
